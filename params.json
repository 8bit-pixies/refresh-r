{"name":"Refresh-r","tagline":"","body":"-   A Warning\r\n-   Data Structures\r\n    -   Vectors\r\n        -   Notes\r\n    -   Lists\r\n    -   DataFrames\r\n    -   Concluding Remarks\r\n-   Programming Structures\r\n    -   For loops\r\n        -   Apply\r\n\r\nA Warning\r\n=========\r\n\r\nThere are many pieces of criticisms on R, some legitable, some not. This\r\nchapter is not an attempt to clear this (mis)understanding, but perhaps\r\nto allow you to approach the topic of \"high performance\" R with an open\r\nmind.\r\n\r\nFirstly, lets consider SAS. What is SAS:\r\n\r\n-   SAS is best described as a procedural language.\r\n-   SAS has a heavy emphasis on black box procedures.\r\n\r\nIn contrast R:\r\n\r\n-   R is often described as object-orientated, but it definitely has\r\n    many functional programming aspects in it.\r\n-   R allows you to define your own functions.\r\n\r\nOf course this is not a definitive list of the differences between SAS\r\nand R but in my opinion is the most difficult one to accept. Too often\r\nwhen people learn a new programming language, they refuse to embrace the\r\nopportunities and differences in the languages, but rather attempt to\r\nenforce their own ideas and knowledge into a small and narrow box. So\r\nwith that in mind, let me emphasis the following statement.\r\n\r\n> Procedural programming and object-orientated/function programming are\r\n> extremely different. Writing R scripts in a procedural style will\r\n> work, but often at the cost of performance.\r\n\r\nSo to prevent this, I will attempt to demonstrate idiomatic R code.\r\n\r\nData Structures\r\n===============\r\n\r\nVectors\r\n-------\r\n\r\nThe power of R comes from vectors. Infact vectorization is the single\r\nmost important idea in producing efficient R code.\r\n\r\nWhat does an R vector look like?\r\n\r\n``` {.r}\r\nvec <- c(1, 2, 3, 4)\r\n```\r\n\r\nLets break down what we can see here first:\r\n\r\n-   `vec` : this is our variable\r\n-   `<-` : this is our assignment (in fact the statement could have been\r\n    written as `vec = c(1,2,3,4)`\r\n-   `c` : this is a function\r\n-   `1,2,3,4` : these are the arguments in the function\r\n\r\nSo far, this isn't anything too different from what we have seen in SAS.\r\n\r\nIn plain english, what the statement above does is:\r\n\r\n> Assigns a vector of numbers (1,2,3,4) into the variable `vec`\r\n\r\nYou may be curious, what is the function `c`. To answer that question,\r\nsimply type `?c` into the console. You will see in the help screen that\r\n`c` is function which forms a vector. Some people refer to the function\r\n`c` as the \"concatentation\" function. To see why, we can extend this\r\nvector by writing\r\n\r\n``` {.r}\r\nc(vec, 5)\r\n```\r\n\r\nwhich will return the vector (1,2,3,4,5) which is the vector above with\r\n5 concatentated onto it.\r\n\r\nYou can access elements in a vector by their index:\r\n\r\n``` {.r}\r\nvec[1]\r\n```\r\n\r\nIf you want to initialise vectors, you can simply type\r\n\r\n``` {.r}\r\nvec <- numeric(10)\r\n```\r\n\r\nAnd it will generate a vector of size 10.\r\n\r\n### Notes\r\n\r\n-   Elements in a vector must all be of the same type. try\r\n    `vec <- c(1, \"abc\"); class(vec)`, and it will be a character vector\r\n-   To initialise large vectors it is best to \"pre-build\" them. It is\r\n    much faster than \"growing\" a vector.\r\n\r\nLists\r\n-----\r\n\r\nList can hold functions, and data of *different* types.\r\n\r\n``` {.r}\r\nlist(1, \"s\", sum)\r\n```\r\n\r\nLists are similar to hash tables or dictionaries in other programming\r\nlanguage. They are similar to vectors except you can access elements by\r\ncalling its index.\r\n\r\n``` {.r}\r\nls <- list('a'=1, 'b'=\"s\", 'func'=sum, 'ls'=list(1,2,3,\"c\"))\r\nls$a\r\nls['b']\r\nls$ls[[1]]\r\n```\r\n\r\nDataFrames\r\n----------\r\n\r\nThis is the R version of the SAS dataset. DataFrames are really just a\r\nspecial version of a list. Infact, DataFrame is more or less just a\r\n\"list of lists\".\r\n\r\n``` {.r}\r\nls <- list('a'= c(1,2,3,4), 'b'=c(\"a\",\"b\",\"c\",\"d\"))\r\ndls <- data.frame(ls)\r\ndls$a\r\ndls$b\r\n```\r\n\r\nConcluding Remarks\r\n------------------\r\n\r\nData structures are a extremely deep topic in R, and a complicated one\r\ntoo. Here I have merely given you an overview of them, but a deep\r\nunderstanding of how they work, and the most efficient way to approach\r\nthem is necessary to create efficient R code.\r\n\r\nProgramming Structures\r\n======================\r\n\r\n`if`, `else`, `for` (`do`), all work in the same way as SAS, with their\r\nanalogous boolean operators, `&&` (`and`), `||` (`or`). Though there are\r\nsome differences.\r\n\r\nFor loops\r\n---------\r\n\r\n`for` loops in R doesn't have to be centered arond indices!\r\n\r\n``` {.r}\r\nfor (el in c(5,4,6,7,8)) {\r\n  print(el)\r\n}\r\n```\r\n\r\nNotice that there isn't any reference to indices. This works for lists\r\nas well\r\n\r\n``` {.r}\r\nfor (el in list('a'=c(1,2,3), 'b'=\"s\")){\r\n  print(el)\r\n}\r\n```\r\n\r\n### Apply\r\n\r\nBut R also has other ways of looping through things. This is through the\r\nfunctional programming idea of \"apply\".\r\n\r\nAs a small detour, in mathematics, we can represent sets, like a set of\r\nall square numbers to be like:\r\n\r\n    {x^2, for all x in N}\r\n\r\nThis can be extended to programming.\r\n\r\nSo lets get a list of all square numbers from one to ten.\r\n\r\n``` {.r}\r\nv <- c()\r\nfor (i in 1:10) {\r\n  v <- c(v, i*i)\r\n}\r\n```\r\n\r\nAn alternative way (and much more efficient) is to use the apply\r\nfunction.\r\n\r\n``` {.r}\r\nsapply(1:10, function(x) x*x)\r\n```\r\n\r\nThis is the idiomatic R way of iterating and applying functions onto a\r\nvectorized object.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}